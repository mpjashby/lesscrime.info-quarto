{"title":"Tutorial: Cleaning UK Office for National Statistics data in R","markdown":{"yaml":{"title":"Tutorial: Cleaning UK Office for National Statistics data in R","author":"Matt Ashby","date":"2019-08-30","tags":["tutorial","R"],"description":"UK Office for National Statistics data can be in formats that are hard to analyse. This tutorial works through how to clean ONS data tables."},"headingText":"Why do this?","containsRefs":false,"markdown":"\n\n```{r include=FALSE}\noptions(\"conflicts.policy\" = list(warn = FALSE))\n```\n\n\nTL; DR: [skip to the complete script](#complete)\n\nThe UK [Office for National Statistics](https://ons.gov.uk/) (ONS) publishes a \nlot of quantitative information on all the topics you'd expect from a national \nstatistical office, but most of it is released in formats that need manual\ncleaning before they can be used for data analysis.\n\n[ONS has started publishing some machine-readable data]()[^3], but most products \nits produces are Excel tables that are optimised for human reading by mimicking \nthe format of tables in the printed statistical reports that ONS produced for \ndecades.\n\nThis tutorial talks through how to clean a human-readable table produced by ONS\nusing the `tidyverse` collection of packages, so the resulting [tidy \ndata](http://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html) can \nbe used for analysis. As an example, we'll use a file containing [population \nestimates for each nation within the United Kingdom](https://www.ons.gov.uk/peoplepopulationandcommunity/populationandmigration/populationestimates/datasets/populationestimatesforukenglandandwalesscotlandandnorthernireland) \nby five-year age groups.\n\n\n\nIt might be tempting not to clean the data in R but instead simply open the\nrelevant file in Excel and make the necessary changes there. This will work, but\nthere are at least three reasons why cleaning the data in Excel is not \nnecessarily a good idea.\n\n  * *It's harder to repeat the process*. For example, if ONS updates the\n    table (either because new data is available or to correct a problem) then\n    you have to repeat the manual process in Excel. If you clean the data in R,\n    typically all you have to do is run the script again.\n  * *It's harder to find mistakes*. If you make a mistake while changing data in\n    Excel but don't notice until later (e.g. if your results don't make sense)\n    it will be difficult to track down exactly what happened. If you use a \n    script to clean the data, you can go back and run it line-by-line to \n    identify the problem.\n  * *It's harder for others to trust your work*. If someone else wants to check\n    your analysis (e.g. before taking action based on it), that's more difficult\n    if you have manipulated the data manually in ways the other person cannot\n    see.\n\n\n# Before you start\n\nThis tutorial assumes you have [R](https://cloud.r-project.org) installed and\nthat you're comfortable with the basics of [using R to manipulate data ](https://www.computerworld.com/article/2497143/business-intelligence-beginner-s-guide-to-r-introduction.html).\nIf you don't have the tidyverse collection of packages installed already, run\n`install.packages(\"tidyverse\")` before continuing. It also a good idea to run\nthis code from [inside a project](https://www.tidyverse.org/articles/2017/12/workflow-vs-script/).\n\n\n# Download the data {#download}\n\nAlthough ONS is relatively good at providing archive data, it's good practice to\nalways save an unamended copy of the raw data for any project just in case it\nlater disappears from the source website.\n\n```{r eval=FALSE}\n# download the data file\ndownload.file(\n  url = \"https://www.ons.gov.uk/file?uri=/peoplepopulationandcommunity/populationandmigration/populationestimates/datasets/populationestimatesforukenglandandwalesscotlandandnorthernireland/mid20182019laboundaries/ukmidyearestimates20182019ladcodes.xls\",\n  destfile = \"ons_pop_data.xls\"\n)\n```\n\n\n# Load the data into R {#load}\n\nSince the data are in an Excel file, we can use the [`readxl`](https://readxl.tidyverse.org) \npackage to read it into R[^2]. ONS publishes data using a mixture of file formats, \nincluding both the pre-2007 Excel `.xls` file format and the current `.xlsx` \nformat[^1]. The `read_excel()` function can handle both `.xls` and `.xlsx` \nfiles, but can only load a single sheet from within an Excel workbook (i.e. \nfile). We can use the `excel_sheets()` function to get the names of each sheet \nin the Excel file.\n\n```{r}\nlibrary(\"readxl\")\nlibrary(\"tidyverse\")\n```\n\n```{r}\nexcel_sheets(\"ons_pop_data.xls\")\n```\n\nNote that some of the sheets have a space at the end of the name, which will be\ninvisible when viewing the file in Excel but which we need to know about to\nspecify the sheet name for `read_excel()`.\n\nThe `Contents ` sheet contains a short description of the data in each of the\nother sheets. There are blank rows between every row in this table (an example\nof how ONS optimises for human rather than computer readability), but we can \nremove these rows using the `drop_na()` function from the `tidyr` package.\n\n```{r paged.print=FALSE}\ndrop_na(read_excel(\"ons_pop_data.xls\", sheet = \"Contents \"))\n```\n\nWe're going to use the data from the mid-2018 UK population summary, so we want\nthe `MYE1` sheet. We can now use `read_excel()` to load the data.\n\n```{r}\nfile_data <- read_excel(\"ons_pop_data.xls\", sheet = \"MYE1\")\n```\n\n\n# Clean the data {#clean}\n\nIn Excel, the `MYE1` sheet looks like this:\n\n![](/post/cleaning-ons-data/mye1-sheet-preview.png)\n\nThe `file_data` object contains the result of the `read_excel()` function's \nattempt to load this sheet into R:\n\n```{r}\nfile_data\n```\n\nThis isn't very useful. There are several problems we need to fix:\n\n  1. the column names don't reflect the data in each column,\n  2. all the columns have the type `<chr>` (character) even when the columns\n     contain numbers,\n  3. there are several blank or partially blank rows,\n  4. the feedback questionnaire in the top-left corner of the sheet means\n     `file_data` contains an extra column,\n  5. there is a row containing a footnote,\n  6. the data are in wide rather than long format.\n\nWe can fix all of these either using the parameters of `read_excel()` or  \nfunctions from the tidyverse packages.\n\nWe can exclude all the cells in the sheet except those containing data with the\n`range = ` parameter of `read_excel()`. We can either specify the cell range\nmanually (e.g. `range = \"A5:H31\"`) or we can use one of the `cell_*` collection\nof helper functions from the `cellranger` package, which is loaded with \n`readxl`.\n\nWe can work out which cells we want to retain either by opening the file in\nExcel and noting which rows contain the data, or by running `View(file_data)` in\nR and then adjusting the value of `range =` in `read_excel()` until we are\nhappy with the result.\n\n```{r}\nfile_data <- read_excel(\"ons_pop_data.xls\",\n  sheet = \"MYE1\",\n  range = cell_rows(5:31)\n)\n\nfile_data\n```\n\nThis deals with the unwanted rows above and below the table, as well as the\nunwanted columns produced because of the feedback questionnaire.\n\nThe next problem is that the column names represent the [GSS statistical\ncodes](https://webarchive.nationalarchives.gov.uk/20160106185615/http://www.ons.gov.uk/ons/guide-method/geography/beginner-s-guide/index.html) \nfor the different nations of the UK, rather than the names of the nations. You \nmay prefer the codes, but we'll assume that you want the names.\n\nWe can use functions from the `magrittr` package to work with individual values\nin the data. All these functions are aliases for base R functions, but can be\neasier to work with.\n\n```{r}\nlibrary(\"magrittr\")\n\n# set a value for the first row in the first column, which is currently blank\nfile_data[1, 1] <- \"group\"\n\n# replace the existing column names with the values from the first row\nfile_data <- set_colnames(file_data, file_data[1, ])\n\n# remove the first row, which we no longer need, using slice() from dplyr\nfile_data <- slice(file_data, 2:n())\n\nfile_data\n```\n\nNext we remove any rows containing empty cells, since none of the data rows\ncontain empty cells (see [Tips](#tips), below, for tables where this isn't the\ncase). \n\n```{r}\nfile_data <- drop_na(file_data)\n\nfile_data\n```\n\nWe can convert the data from wide to long using `gather()` from the `tidyr`\npackage. `gather()` can be a slightly confusing function to use, but there are\nsome useful tutorials available by [Garrett Grolemund](https://garrettgman.github.io/tidying/#gather), [UC Business Analytics](https://uc-r.github.io/tidyr#gather--function) and [R for Data\nScience](https://r4ds.had.co.nz/tidy-data.html#spreading-and-gathering).\n\n```{r}\nfile_data <- gather(file_data, key = \"geography\", value = \"population\", -group)\n\nfile_data\n```\n\nFinally, we will neaten the data by converting the population variable to \nnumeric and the geography variable to title case (using a function from the\n`stringr` package).\n\n```{r}\ntidy_data <- mutate(\n  file_data,\n  geography = str_to_title(geography),\n  population = as.numeric(population)\n)\n\ntidy_data\n```\n\n\n# A complete script {#complete}\n\nUsing the [`magrittr` pipe `%>%`](https://cran.r-project.org/package=magrittr/vignettes/magrittr.html), \nwe can combine all these cleaning steps together, which makes the code more \ncompact and (arguably) more readable.\n\n```\nlibrary(\"lubridate\") # lubridate and magrittr are part of the\nlibrary(\"magrittr\") # tidyverse but not loaded with it by default\nlibrary(\"readxl\")\nlibrary(\"tidyverse\")\n\ntidy_data <- read_excel(\"ons_pop_data.xls\",\n  sheet = \"MYE1\",\n  range = cell_rows(5:31)\n) %>%\n  inset(1, 1, \"group\") %>%\n  set_colnames(.[1, ]) %>%\n  slice(2:n()) %>%\n  drop_na() %>%\n  gather(key = \"geography\", value = \"population\", -group) %>%\n  mutate(\n    geography = str_to_title(geography),\n    population = as.numeric(population)\n  )\n\n```\n\n\n# Tips for other ONS tables {#tips}\n\nThere is a huge number of ONS tables available, some having different formatting\nissues from those mentioned above. These are some of the issues I've come across\nand potential ways to deal with them.\n\n(The examples below all assume your data is in a data frame/tibble called \n`data`.)\n\n\n## Missing values in the data\n\nMany ONS datasets have missing values, and some even have multiple \nvalues representing different reasons for the values being missing. For example,\ndata for small geographic areas might be missing because the data could not be\ncollected for a particular location or have been redacted to prevent disclosure\nof personal information.\n\nThe `na = ` parameter of `read_excel()` can be used to specify values in the\ndata that should be treated as missing. For example, if an ONS table uses a\nblank cell to represent data that could not be collected and `**` to represent\nredacted data, `read_excel(\"data.xlsx\", sheet = \"Sheet 1\", na = c(\"\", \"**\"))`\nwill ensure both values are represented by `NA` in R.\n\nIt isn't possible to use `drop_na()` to remove empty rows if there are missing \nvalues in the data, because `drop_na()` removes rows that contain *any* missing\nvalues. Instead, you can use `remove_empty()` from the `janitor` package to \nremove rows or columns that are entirely empty. If there are rows that you want\nto remove from the data that contain some missing values and some values that\nare not missing, use `filter()` from `dplyr` based on the value of a specific\ncolumn. For example, to remove rows with the value of `population` missing,\nuse `filter(data, !is.na(population))`. To remove single rows manually by row \nnumber, use `slice()`, also from `dplyr`.\n\n\n## Multiple tables in a single sheet\n\nSometimes multiple related data tables are placed on a single Excel sheet. You\ncan either import them separately and then combine the resulting datasets \nmanually (e.g. with `rbind()`) or just treat the rows or columns between each\ntable as clutter that can be removed using a combination of `drop_na()` and \n`slice()` as above. In the latter case, modify the `range = ` argument of \n`read_excel()` so that the selected cells/rows/columns include all the tables.\n\n\n## Category names or values with footnote markers\n\nIf tables have multiple footnotes, some categories or values may end in a\nfootnote marker (typically a number). To remove these, use `str_remove()` from\n`stringr`. For example, if the column `place` contains values with footnote\nmarkers, you can use `mutate(data, place = str_remove(place, \"\\\\d+$\"))` to \nremove them, where `\\\\d+` is a [regular expression that matches one or more \nnumeric characters](https://stringr.tidyverse.org/articles/regular-expressions.html#matching-multiple-characters)\nand [`$` matches only numeric characters at the end of the\nvalue](https://stringr.tidyverse.org/articles/regular-expressions.html#anchors) \nof `place`. This only works for non-numeric values with numeric footnote \nmarkers, since the regular expression `\\\\d+$` will match any sequence of numbers \nat the end of a cell.\n\n\n## Dates and date ranges stored as text\n\nSince many ONS statistics are published for financial years, time periods are\noften stored as strings showing, for example, `2018-19`. Converting these to\ndates helps with things like plotting values on an axis with date values or\nusing the data in a time-series model.\n\nThe `lubridate` package is very useful for converting dates. You can either\nrepresent each date as a specific moment in time, or as an interval in time.\nFor example, if a financial year is stored as `2018-19` in the `year` column,\nyou can extract the specific moment the year started using\n`mutate(year_beginning = ymd(paste(str_sub(year, 0, 4)), \"04\", \"01\"))`. In this\ncode, `str_sub(year, 0, 4)` extracts the first four characters from the string\n`2018-19`, `paste()` creates a single character value for 1 April in the given\nyear (e.g. `2018 04 01`) and `ymd()` converts that string into a date object.\n\nTo store a date as an interval, we extract both the date on which the year \nstarted and the date it ended. For example,\n\n```{r eval=FALSE}\nmutate(\n  data,\n  year_interval = interval(\n    ymd(paste(str_sub(year, 0, 4), \"04\", \"01\")),\n    ymd(paste(str_sub(year, -2), \"03\", \"31\"))\n  )\n)\n```\n\n\n## R session information\n\nThe code in this tutorial was run in R with the following configuration:\n\n```{r echo=FALSE}\nsessionInfo()\n```\n\n[^1]: I have not been able to work out why some ONS files are in `.xls` format\nand some in `.xlsx`.\n\n[^2]: The `readxl` package is [installed as part of the \ntidyverse](https://www.tidyverse.org/packages/) but is not automatically loaded \nby `library(\"tidyverse\")`.\n\n[^3]: ONS refers to this as 'open data', although (almost) all the products it \nproduces are already [open licensed under the Open Government\nLicence](https://www.ons.gov.uk/methodology/geography/licences)\n","srcMarkdownNoYaml":"\n\n```{r include=FALSE}\noptions(\"conflicts.policy\" = list(warn = FALSE))\n```\n\n\nTL; DR: [skip to the complete script](#complete)\n\nThe UK [Office for National Statistics](https://ons.gov.uk/) (ONS) publishes a \nlot of quantitative information on all the topics you'd expect from a national \nstatistical office, but most of it is released in formats that need manual\ncleaning before they can be used for data analysis.\n\n[ONS has started publishing some machine-readable data]()[^3], but most products \nits produces are Excel tables that are optimised for human reading by mimicking \nthe format of tables in the printed statistical reports that ONS produced for \ndecades.\n\nThis tutorial talks through how to clean a human-readable table produced by ONS\nusing the `tidyverse` collection of packages, so the resulting [tidy \ndata](http://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html) can \nbe used for analysis. As an example, we'll use a file containing [population \nestimates for each nation within the United Kingdom](https://www.ons.gov.uk/peoplepopulationandcommunity/populationandmigration/populationestimates/datasets/populationestimatesforukenglandandwalesscotlandandnorthernireland) \nby five-year age groups.\n\n\n# Why do this?\n\nIt might be tempting not to clean the data in R but instead simply open the\nrelevant file in Excel and make the necessary changes there. This will work, but\nthere are at least three reasons why cleaning the data in Excel is not \nnecessarily a good idea.\n\n  * *It's harder to repeat the process*. For example, if ONS updates the\n    table (either because new data is available or to correct a problem) then\n    you have to repeat the manual process in Excel. If you clean the data in R,\n    typically all you have to do is run the script again.\n  * *It's harder to find mistakes*. If you make a mistake while changing data in\n    Excel but don't notice until later (e.g. if your results don't make sense)\n    it will be difficult to track down exactly what happened. If you use a \n    script to clean the data, you can go back and run it line-by-line to \n    identify the problem.\n  * *It's harder for others to trust your work*. If someone else wants to check\n    your analysis (e.g. before taking action based on it), that's more difficult\n    if you have manipulated the data manually in ways the other person cannot\n    see.\n\n\n# Before you start\n\nThis tutorial assumes you have [R](https://cloud.r-project.org) installed and\nthat you're comfortable with the basics of [using R to manipulate data ](https://www.computerworld.com/article/2497143/business-intelligence-beginner-s-guide-to-r-introduction.html).\nIf you don't have the tidyverse collection of packages installed already, run\n`install.packages(\"tidyverse\")` before continuing. It also a good idea to run\nthis code from [inside a project](https://www.tidyverse.org/articles/2017/12/workflow-vs-script/).\n\n\n# Download the data {#download}\n\nAlthough ONS is relatively good at providing archive data, it's good practice to\nalways save an unamended copy of the raw data for any project just in case it\nlater disappears from the source website.\n\n```{r eval=FALSE}\n# download the data file\ndownload.file(\n  url = \"https://www.ons.gov.uk/file?uri=/peoplepopulationandcommunity/populationandmigration/populationestimates/datasets/populationestimatesforukenglandandwalesscotlandandnorthernireland/mid20182019laboundaries/ukmidyearestimates20182019ladcodes.xls\",\n  destfile = \"ons_pop_data.xls\"\n)\n```\n\n\n# Load the data into R {#load}\n\nSince the data are in an Excel file, we can use the [`readxl`](https://readxl.tidyverse.org) \npackage to read it into R[^2]. ONS publishes data using a mixture of file formats, \nincluding both the pre-2007 Excel `.xls` file format and the current `.xlsx` \nformat[^1]. The `read_excel()` function can handle both `.xls` and `.xlsx` \nfiles, but can only load a single sheet from within an Excel workbook (i.e. \nfile). We can use the `excel_sheets()` function to get the names of each sheet \nin the Excel file.\n\n```{r}\nlibrary(\"readxl\")\nlibrary(\"tidyverse\")\n```\n\n```{r}\nexcel_sheets(\"ons_pop_data.xls\")\n```\n\nNote that some of the sheets have a space at the end of the name, which will be\ninvisible when viewing the file in Excel but which we need to know about to\nspecify the sheet name for `read_excel()`.\n\nThe `Contents ` sheet contains a short description of the data in each of the\nother sheets. There are blank rows between every row in this table (an example\nof how ONS optimises for human rather than computer readability), but we can \nremove these rows using the `drop_na()` function from the `tidyr` package.\n\n```{r paged.print=FALSE}\ndrop_na(read_excel(\"ons_pop_data.xls\", sheet = \"Contents \"))\n```\n\nWe're going to use the data from the mid-2018 UK population summary, so we want\nthe `MYE1` sheet. We can now use `read_excel()` to load the data.\n\n```{r}\nfile_data <- read_excel(\"ons_pop_data.xls\", sheet = \"MYE1\")\n```\n\n\n# Clean the data {#clean}\n\nIn Excel, the `MYE1` sheet looks like this:\n\n![](/post/cleaning-ons-data/mye1-sheet-preview.png)\n\nThe `file_data` object contains the result of the `read_excel()` function's \nattempt to load this sheet into R:\n\n```{r}\nfile_data\n```\n\nThis isn't very useful. There are several problems we need to fix:\n\n  1. the column names don't reflect the data in each column,\n  2. all the columns have the type `<chr>` (character) even when the columns\n     contain numbers,\n  3. there are several blank or partially blank rows,\n  4. the feedback questionnaire in the top-left corner of the sheet means\n     `file_data` contains an extra column,\n  5. there is a row containing a footnote,\n  6. the data are in wide rather than long format.\n\nWe can fix all of these either using the parameters of `read_excel()` or  \nfunctions from the tidyverse packages.\n\nWe can exclude all the cells in the sheet except those containing data with the\n`range = ` parameter of `read_excel()`. We can either specify the cell range\nmanually (e.g. `range = \"A5:H31\"`) or we can use one of the `cell_*` collection\nof helper functions from the `cellranger` package, which is loaded with \n`readxl`.\n\nWe can work out which cells we want to retain either by opening the file in\nExcel and noting which rows contain the data, or by running `View(file_data)` in\nR and then adjusting the value of `range =` in `read_excel()` until we are\nhappy with the result.\n\n```{r}\nfile_data <- read_excel(\"ons_pop_data.xls\",\n  sheet = \"MYE1\",\n  range = cell_rows(5:31)\n)\n\nfile_data\n```\n\nThis deals with the unwanted rows above and below the table, as well as the\nunwanted columns produced because of the feedback questionnaire.\n\nThe next problem is that the column names represent the [GSS statistical\ncodes](https://webarchive.nationalarchives.gov.uk/20160106185615/http://www.ons.gov.uk/ons/guide-method/geography/beginner-s-guide/index.html) \nfor the different nations of the UK, rather than the names of the nations. You \nmay prefer the codes, but we'll assume that you want the names.\n\nWe can use functions from the `magrittr` package to work with individual values\nin the data. All these functions are aliases for base R functions, but can be\neasier to work with.\n\n```{r}\nlibrary(\"magrittr\")\n\n# set a value for the first row in the first column, which is currently blank\nfile_data[1, 1] <- \"group\"\n\n# replace the existing column names with the values from the first row\nfile_data <- set_colnames(file_data, file_data[1, ])\n\n# remove the first row, which we no longer need, using slice() from dplyr\nfile_data <- slice(file_data, 2:n())\n\nfile_data\n```\n\nNext we remove any rows containing empty cells, since none of the data rows\ncontain empty cells (see [Tips](#tips), below, for tables where this isn't the\ncase). \n\n```{r}\nfile_data <- drop_na(file_data)\n\nfile_data\n```\n\nWe can convert the data from wide to long using `gather()` from the `tidyr`\npackage. `gather()` can be a slightly confusing function to use, but there are\nsome useful tutorials available by [Garrett Grolemund](https://garrettgman.github.io/tidying/#gather), [UC Business Analytics](https://uc-r.github.io/tidyr#gather--function) and [R for Data\nScience](https://r4ds.had.co.nz/tidy-data.html#spreading-and-gathering).\n\n```{r}\nfile_data <- gather(file_data, key = \"geography\", value = \"population\", -group)\n\nfile_data\n```\n\nFinally, we will neaten the data by converting the population variable to \nnumeric and the geography variable to title case (using a function from the\n`stringr` package).\n\n```{r}\ntidy_data <- mutate(\n  file_data,\n  geography = str_to_title(geography),\n  population = as.numeric(population)\n)\n\ntidy_data\n```\n\n\n# A complete script {#complete}\n\nUsing the [`magrittr` pipe `%>%`](https://cran.r-project.org/package=magrittr/vignettes/magrittr.html), \nwe can combine all these cleaning steps together, which makes the code more \ncompact and (arguably) more readable.\n\n```\nlibrary(\"lubridate\") # lubridate and magrittr are part of the\nlibrary(\"magrittr\") # tidyverse but not loaded with it by default\nlibrary(\"readxl\")\nlibrary(\"tidyverse\")\n\ntidy_data <- read_excel(\"ons_pop_data.xls\",\n  sheet = \"MYE1\",\n  range = cell_rows(5:31)\n) %>%\n  inset(1, 1, \"group\") %>%\n  set_colnames(.[1, ]) %>%\n  slice(2:n()) %>%\n  drop_na() %>%\n  gather(key = \"geography\", value = \"population\", -group) %>%\n  mutate(\n    geography = str_to_title(geography),\n    population = as.numeric(population)\n  )\n\n```\n\n\n# Tips for other ONS tables {#tips}\n\nThere is a huge number of ONS tables available, some having different formatting\nissues from those mentioned above. These are some of the issues I've come across\nand potential ways to deal with them.\n\n(The examples below all assume your data is in a data frame/tibble called \n`data`.)\n\n\n## Missing values in the data\n\nMany ONS datasets have missing values, and some even have multiple \nvalues representing different reasons for the values being missing. For example,\ndata for small geographic areas might be missing because the data could not be\ncollected for a particular location or have been redacted to prevent disclosure\nof personal information.\n\nThe `na = ` parameter of `read_excel()` can be used to specify values in the\ndata that should be treated as missing. For example, if an ONS table uses a\nblank cell to represent data that could not be collected and `**` to represent\nredacted data, `read_excel(\"data.xlsx\", sheet = \"Sheet 1\", na = c(\"\", \"**\"))`\nwill ensure both values are represented by `NA` in R.\n\nIt isn't possible to use `drop_na()` to remove empty rows if there are missing \nvalues in the data, because `drop_na()` removes rows that contain *any* missing\nvalues. Instead, you can use `remove_empty()` from the `janitor` package to \nremove rows or columns that are entirely empty. If there are rows that you want\nto remove from the data that contain some missing values and some values that\nare not missing, use `filter()` from `dplyr` based on the value of a specific\ncolumn. For example, to remove rows with the value of `population` missing,\nuse `filter(data, !is.na(population))`. To remove single rows manually by row \nnumber, use `slice()`, also from `dplyr`.\n\n\n## Multiple tables in a single sheet\n\nSometimes multiple related data tables are placed on a single Excel sheet. You\ncan either import them separately and then combine the resulting datasets \nmanually (e.g. with `rbind()`) or just treat the rows or columns between each\ntable as clutter that can be removed using a combination of `drop_na()` and \n`slice()` as above. In the latter case, modify the `range = ` argument of \n`read_excel()` so that the selected cells/rows/columns include all the tables.\n\n\n## Category names or values with footnote markers\n\nIf tables have multiple footnotes, some categories or values may end in a\nfootnote marker (typically a number). To remove these, use `str_remove()` from\n`stringr`. For example, if the column `place` contains values with footnote\nmarkers, you can use `mutate(data, place = str_remove(place, \"\\\\d+$\"))` to \nremove them, where `\\\\d+` is a [regular expression that matches one or more \nnumeric characters](https://stringr.tidyverse.org/articles/regular-expressions.html#matching-multiple-characters)\nand [`$` matches only numeric characters at the end of the\nvalue](https://stringr.tidyverse.org/articles/regular-expressions.html#anchors) \nof `place`. This only works for non-numeric values with numeric footnote \nmarkers, since the regular expression `\\\\d+$` will match any sequence of numbers \nat the end of a cell.\n\n\n## Dates and date ranges stored as text\n\nSince many ONS statistics are published for financial years, time periods are\noften stored as strings showing, for example, `2018-19`. Converting these to\ndates helps with things like plotting values on an axis with date values or\nusing the data in a time-series model.\n\nThe `lubridate` package is very useful for converting dates. You can either\nrepresent each date as a specific moment in time, or as an interval in time.\nFor example, if a financial year is stored as `2018-19` in the `year` column,\nyou can extract the specific moment the year started using\n`mutate(year_beginning = ymd(paste(str_sub(year, 0, 4)), \"04\", \"01\"))`. In this\ncode, `str_sub(year, 0, 4)` extracts the first four characters from the string\n`2018-19`, `paste()` creates a single character value for 1 April in the given\nyear (e.g. `2018 04 01`) and `ymd()` converts that string into a date object.\n\nTo store a date as an interval, we extract both the date on which the year \nstarted and the date it ended. For example,\n\n```{r eval=FALSE}\nmutate(\n  data,\n  year_interval = interval(\n    ymd(paste(str_sub(year, 0, 4), \"04\", \"01\")),\n    ymd(paste(str_sub(year, -2), \"03\", \"31\"))\n  )\n)\n```\n\n\n## R session information\n\nThe code in this tutorial was run in R with the following configuration:\n\n```{r echo=FALSE}\nsessionInfo()\n```\n\n[^1]: I have not been able to work out why some ONS files are in `.xls` format\nand some in `.xlsx`.\n\n[^2]: The `readxl` package is [installed as part of the \ntidyverse](https://www.tidyverse.org/packages/) but is not automatically loaded \nby `library(\"tidyverse\")`.\n\n[^3]: ONS refers to this as 'open data', although (almost) all the products it \nproduces are already [open licensed under the Open Government\nLicence](https://www.ons.gov.uk/methodology/geography/licences)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.551","author":[{"name":"Matt Ashby"},"Matt Ashby"],"theme":["sandstone","../../custom.scss"],"date-format":"D MMM YYYY","title":"Tutorial: Cleaning UK Office for National Statistics data in R","date":"2019-08-30","tags":["tutorial","R"],"description":"UK Office for National Statistics data can be in formats that are hard to analyse. This tutorial works through how to clean ONS data tables."},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}