{
  "hash": "bf4bc81da0819e22c58dd4a6c6ead3c9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tutorial: Cleaning UK Office for National Statistics data in R\"\nauthor: Matt Ashby\ndate: '2019-08-30'\ntags:\n  - tutorial\n  - R\ndescription: \n  UK Office for National Statistics data can be in formats that are hard to \n  analyse. This tutorial works through how to clean ONS data tables.\n---\n\n\n\n\n\nTL; DR: [skip to the complete script](#complete)\n\nThe UK [Office for National Statistics](https://ons.gov.uk/) (ONS) publishes a \nlot of quantitative information on all the topics you'd expect from a national \nstatistical office, but most of it is released in formats that need manual\ncleaning before they can be used for data analysis.\n\n[ONS has started publishing some machine-readable data]()[^3], but most products \nits produces are Excel tables that are optimised for human reading by mimicking \nthe format of tables in the printed statistical reports that ONS produced for \ndecades.\n\nThis tutorial talks through how to clean a human-readable table produced by ONS\nusing the `tidyverse` collection of packages, so the resulting [tidy \ndata](http://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html) can \nbe used for analysis. As an example, we'll use a file containing [population \nestimates for each nation within the United Kingdom](https://www.ons.gov.uk/peoplepopulationandcommunity/populationandmigration/populationestimates/datasets/populationestimatesforukenglandandwalesscotlandandnorthernireland) \nby five-year age groups.\n\n\n# Why do this?\n\nIt might be tempting not to clean the data in R but instead simply open the\nrelevant file in Excel and make the necessary changes there. This will work, but\nthere are at least three reasons why cleaning the data in Excel is not \nnecessarily a good idea.\n\n  * *It's harder to repeat the process*. For example, if ONS updates the\n    table (either because new data is available or to correct a problem) then\n    you have to repeat the manual process in Excel. If you clean the data in R,\n    typically all you have to do is run the script again.\n  * *It's harder to find mistakes*. If you make a mistake while changing data in\n    Excel but don't notice until later (e.g. if your results don't make sense)\n    it will be difficult to track down exactly what happened. If you use a \n    script to clean the data, you can go back and run it line-by-line to \n    identify the problem.\n  * *It's harder for others to trust your work*. If someone else wants to check\n    your analysis (e.g. before taking action based on it), that's more difficult\n    if you have manipulated the data manually in ways the other person cannot\n    see.\n\n\n# Before you start\n\nThis tutorial assumes you have [R](https://cloud.r-project.org) installed and\nthat you're comfortable with the basics of [using R to manipulate data ](https://www.computerworld.com/article/2497143/business-intelligence-beginner-s-guide-to-r-introduction.html).\nIf you don't have the tidyverse collection of packages installed already, run\n`install.packages(\"tidyverse\")` before continuing. It also a good idea to run\nthis code from [inside a project](https://www.tidyverse.org/articles/2017/12/workflow-vs-script/).\n\n\n# Download the data {#download}\n\nAlthough ONS is relatively good at providing archive data, it's good practice to\nalways save an unamended copy of the raw data for any project just in case it\nlater disappears from the source website.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# download the data file\ndownload.file(\n  url = \"https://www.ons.gov.uk/file?uri=/peoplepopulationandcommunity/populationandmigration/populationestimates/datasets/populationestimatesforukenglandandwalesscotlandandnorthernireland/mid20182019laboundaries/ukmidyearestimates20182019ladcodes.xls\",\n  destfile = \"ons_pop_data.xls\"\n)\n```\n:::\n\n\n\n# Load the data into R {#load}\n\nSince the data are in an Excel file, we can use the [`readxl`](https://readxl.tidyverse.org) \npackage to read it into R[^2]. ONS publishes data using a mixture of file formats, \nincluding both the pre-2007 Excel `.xls` file format and the current `.xlsx` \nformat[^1]. The `read_excel()` function can handle both `.xls` and `.xlsx` \nfiles, but can only load a single sheet from within an Excel workbook (i.e. \nfile). We can use the `excel_sheets()` function to get the names of each sheet \nin the Excel file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"readxl\")\nlibrary(\"tidyverse\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nexcel_sheets(\"ons_pop_data.xls\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Contents \"                  \"Terms and conditions \"     \n [3] \"Notes and definitions\"      \"Admin. geography hierarchy\"\n [5] \"MYE1\"                       \"MYE2-All\"                  \n [7] \"MYE2 - Males\"               \"MYE2 - Females\"            \n [9] \"MYE3\"                       \"MYE4 \"                     \n[11] \"MYE 5\"                      \"MYE 6\"                     \n[13] \"Related publications\"      \n```\n\n\n:::\n:::\n\n\nNote that some of the sheets have a space at the end of the name, which will be\ninvisible when viewing the file in Excel but which we need to know about to\nspecify the sheet name for `read_excel()`.\n\nThe `Contents ` sheet contains a short description of the data in each of the\nother sheets. There are blank rows between every row in this table (an example\nof how ONS optimises for human rather than computer readability), but we can \nremove these rows using the `drop_na()` function from the `tidyr` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrop_na(read_excel(\"ons_pop_data.xls\", sheet = \"Contents \"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 2\n   Contents                   Population Estimates for UK, England and Wales, …¹\n   <chr>                      <chr>                                             \n 1 Terms and conditions       Terms and conditions                              \n 2 Notes and definitions      Notes and definitions                             \n 3 Admin. geography hierarchy Administrative geography hierarchy for the United…\n 4 MYE1                       Population estimates: Summary for the UK, mid-2018\n 5 MYE2 - All                 Population estimates: Persons by single year of a…\n 6 MYE2 - M                   Population estimates: Males by single year of age…\n 7 MYE2 - F                   Population estimates: Females by single year of a…\n 8 MYE3                       Components of population change for local authori…\n 9 MYE4                       Population estimates: Summary for the UK, mid-197…\n10 MYE5                       Population estimates: Population density for loca…\n11 MYE6                       Median age of population for local authorities in…\n12 Related publications       Provides links to further population statistics &…\n# ℹ abbreviated name:\n#   ¹​`Population Estimates for UK, England and Wales, Scotland and Northern Ireland: Mid-2018, using April 2019 local authority district codes`\n```\n\n\n:::\n:::\n\n\nWe're going to use the data from the mid-2018 UK population summary, so we want\nthe `MYE1` sheet. We can now use `read_excel()` to load the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_data <- read_excel(\"ons_pop_data.xls\", sheet = \"MYE1\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNew names:\n• `` -> `...2`\n• `` -> `...3`\n• `` -> `...4`\n• `` -> `...5`\n• `` -> `...6`\n• `` -> `...7`\n• `` -> `...8`\n• `` -> `...9`\n```\n\n\n:::\n:::\n\n\n\n# Clean the data {#clean}\n\nIn Excel, the `MYE1` sheet looks like this:\n\n![](/post/cleaning-ons-data/mye1-sheet-preview.png)\n\nThe `file_data` object contains the result of the `read_excel()` function's \nattempt to load this sheet into R:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 33 × 9\n   Contents                      ...2  ...3  ...4  ...5  ...6  ...7  ...8  ...9 \n   <chr>                         <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr>\n 1 <NA>                          <NA>  <NA>  <NA>  <NA>   <NA> <NA>  <NA>   <NA>\n 2 MYE1: Population estimates: … <NA>  <NA>  <NA>  <NA>  \"Ple… This… I ne… \"Thi…\n 3 <NA>                          <NA>  <NA>  <NA>  <NA>   <NA> <NA>  <NA>   <NA>\n 4 Country / Code                K020… K030… K040… E920… \"W92… S920… N920…  <NA>\n 5 <NA>                          UNIT… GREA… ENGL… ENGL… \"WAL… SCOT… NORT…  <NA>\n 6 <NA>                          <NA>  <NA>  <NA>  <NA>   <NA> <NA>  <NA>   <NA>\n 7 All Persons                   6643… 6455… 5911… 5597… \"313… 5438… 1881…  <NA>\n 8 Males                         3279… 3186… 2921… 2766… \"154… 2648… 9262…  <NA>\n 9 Females                       3364… 3268… 2990… 2830… \"159… 2789… 9554…  <NA>\n10 <NA>                          <NA>  <NA>  <NA>  <NA>   <NA> <NA>  <NA>   <NA>\n# ℹ 23 more rows\n```\n\n\n:::\n:::\n\n\nThis isn't very useful. There are several problems we need to fix:\n\n  1. the column names don't reflect the data in each column,\n  2. all the columns have the type `<chr>` (character) even when the columns\n     contain numbers,\n  3. there are several blank or partially blank rows,\n  4. the feedback questionnaire in the top-left corner of the sheet means\n     `file_data` contains an extra column,\n  5. there is a row containing a footnote,\n  6. the data are in wide rather than long format.\n\nWe can fix all of these either using the parameters of `read_excel()` or  \nfunctions from the tidyverse packages.\n\nWe can exclude all the cells in the sheet except those containing data with the\n`range = ` parameter of `read_excel()`. We can either specify the cell range\nmanually (e.g. `range = \"A5:H31\"`) or we can use one of the `cell_*` collection\nof helper functions from the `cellranger` package, which is loaded with \n`readxl`.\n\nWe can work out which cells we want to retain either by opening the file in\nExcel and noting which rows contain the data, or by running `View(file_data)` in\nR and then adjusting the value of `range =` in `read_excel()` until we are\nhappy with the result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_data <- read_excel(\"ons_pop_data.xls\",\n  sheet = \"MYE1\",\n  range = cell_rows(5:31)\n)\n\nfile_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 26 × 8\n   `Country / Code` K02000001  K03000001 K04000001 E92000001 W92000004 S92000003\n   <chr>            <chr>      <chr>     <chr>     <chr>     <chr>     <chr>    \n 1 <NA>             UNITED KI… GREAT BR… ENGLAND … ENGLAND   WALES     SCOTLAND \n 2 <NA>             <NA>       <NA>      <NA>      <NA>      <NA>      <NA>     \n 3 All Persons      66435550   64553909  59115809  55977178  3138631   5438100  \n 4 Males            32790202   31864002  29215251  27667942  1547309   2648751  \n 5 Females          33645348   32689907  29900558  28309236  1591322   2789349  \n 6 <NA>             <NA>       <NA>      <NA>      <NA>      <NA>      <NA>     \n 7 Age Groups       <NA>       <NA>      <NA>      <NA>      <NA>      <NA>     \n 8 0-4              3914028    3792292   3515430   3346727   168703    276862   \n 9 5-9              4138524    4009409   3708320   3523866   184454    301089   \n10 10-14            3858894    3738572   3450782   3274119   176663    287790   \n# ℹ 16 more rows\n# ℹ 1 more variable: N92000002 <chr>\n```\n\n\n:::\n:::\n\n\nThis deals with the unwanted rows above and below the table, as well as the\nunwanted columns produced because of the feedback questionnaire.\n\nThe next problem is that the column names represent the [GSS statistical\ncodes](https://webarchive.nationalarchives.gov.uk/20160106185615/http://www.ons.gov.uk/ons/guide-method/geography/beginner-s-guide/index.html) \nfor the different nations of the UK, rather than the names of the nations. You \nmay prefer the codes, but we'll assume that you want the names.\n\nWe can use functions from the `magrittr` package to work with individual values\nin the data. All these functions are aliases for base R functions, but can be\neasier to work with.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"magrittr\")\n\n# set a value for the first row in the first column, which is currently blank\nfile_data[1, 1] <- \"group\"\n\n# replace the existing column names with the values from the first row\nfile_data <- set_colnames(file_data, file_data[1, ])\n\n# remove the first row, which we no longer need, using slice() from dplyr\nfile_data <- slice(file_data, 2:n())\n\nfile_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 25 × 8\n   group      `UNITED KINGDOM` `GREAT BRITAIN` `ENGLAND AND WALES` ENGLAND WALES\n   <chr>      <chr>            <chr>           <chr>               <chr>   <chr>\n 1 <NA>       <NA>             <NA>            <NA>                <NA>    <NA> \n 2 All Perso… 66435550         64553909        59115809            559771… 3138…\n 3 Males      32790202         31864002        29215251            276679… 1547…\n 4 Females    33645348         32689907        29900558            283092… 1591…\n 5 <NA>       <NA>             <NA>            <NA>                <NA>    <NA> \n 6 Age Groups <NA>             <NA>            <NA>                <NA>    <NA> \n 7 0-4        3914028          3792292         3515430             3346727 1687…\n 8 5-9        4138524          4009409         3708320             3523866 1844…\n 9 10-14      3858894          3738572         3450782             3274119 1766…\n10 15-19      3669250          3555359         3270795             3096575 1742…\n# ℹ 15 more rows\n# ℹ 2 more variables: SCOTLAND <chr>, `NORTHERN IRELAND` <chr>\n```\n\n\n:::\n:::\n\n\nNext we remove any rows containing empty cells, since none of the data rows\ncontain empty cells (see [Tips](#tips), below, for tables where this isn't the\ncase). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_data <- drop_na(file_data)\n\nfile_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 22 × 8\n   group      `UNITED KINGDOM` `GREAT BRITAIN` `ENGLAND AND WALES` ENGLAND WALES\n   <chr>      <chr>            <chr>           <chr>               <chr>   <chr>\n 1 All Perso… 66435550         64553909        59115809            559771… 3138…\n 2 Males      32790202         31864002        29215251            276679… 1547…\n 3 Females    33645348         32689907        29900558            283092… 1591…\n 4 0-4        3914028          3792292         3515430             3346727 1687…\n 5 5-9        4138524          4009409         3708320             3523866 1844…\n 6 10-14      3858894          3738572         3450782             3274119 1766…\n 7 15-19      3669250          3555359         3270795             3096575 1742…\n 8 20-24      4184575          4068584         3717960             3512654 2053…\n 9 25-29      4527175          4404612         4022272             3815924 2063…\n10 30-34      4463357          4337288         3976030             3787597 1884…\n# ℹ 12 more rows\n# ℹ 2 more variables: SCOTLAND <chr>, `NORTHERN IRELAND` <chr>\n```\n\n\n:::\n:::\n\n\nWe can convert the data from wide to long using `gather()` from the `tidyr`\npackage. `gather()` can be a slightly confusing function to use, but there are\nsome useful tutorials available by [Garrett Grolemund](https://garrettgman.github.io/tidying/#gather), [UC Business Analytics](https://uc-r.github.io/tidyr#gather--function) and [R for Data\nScience](https://r4ds.had.co.nz/tidy-data.html#spreading-and-gathering).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_data <- gather(file_data, key = \"geography\", value = \"population\", -group)\n\nfile_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 154 × 3\n   group       geography      population\n   <chr>       <chr>          <chr>     \n 1 All Persons UNITED KINGDOM 66435550  \n 2 Males       UNITED KINGDOM 32790202  \n 3 Females     UNITED KINGDOM 33645348  \n 4 0-4         UNITED KINGDOM 3914028   \n 5 5-9         UNITED KINGDOM 4138524   \n 6 10-14       UNITED KINGDOM 3858894   \n 7 15-19       UNITED KINGDOM 3669250   \n 8 20-24       UNITED KINGDOM 4184575   \n 9 25-29       UNITED KINGDOM 4527175   \n10 30-34       UNITED KINGDOM 4463357   \n# ℹ 144 more rows\n```\n\n\n:::\n:::\n\n\nFinally, we will neaten the data by converting the population variable to \nnumeric and the geography variable to title case (using a function from the\n`stringr` package).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_data <- mutate(\n  file_data,\n  geography = str_to_title(geography),\n  population = as.numeric(population)\n)\n\ntidy_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 154 × 3\n   group       geography      population\n   <chr>       <chr>               <dbl>\n 1 All Persons United Kingdom   66435550\n 2 Males       United Kingdom   32790202\n 3 Females     United Kingdom   33645348\n 4 0-4         United Kingdom    3914028\n 5 5-9         United Kingdom    4138524\n 6 10-14       United Kingdom    3858894\n 7 15-19       United Kingdom    3669250\n 8 20-24       United Kingdom    4184575\n 9 25-29       United Kingdom    4527175\n10 30-34       United Kingdom    4463357\n# ℹ 144 more rows\n```\n\n\n:::\n:::\n\n\n\n# A complete script {#complete}\n\nUsing the [`magrittr` pipe `%>%`](https://cran.r-project.org/package=magrittr/vignettes/magrittr.html), \nwe can combine all these cleaning steps together, which makes the code more \ncompact and (arguably) more readable.\n\n```\nlibrary(\"lubridate\") # lubridate and magrittr are part of the\nlibrary(\"magrittr\") # tidyverse but not loaded with it by default\nlibrary(\"readxl\")\nlibrary(\"tidyverse\")\n\ntidy_data <- read_excel(\"ons_pop_data.xls\",\n  sheet = \"MYE1\",\n  range = cell_rows(5:31)\n) %>%\n  inset(1, 1, \"group\") %>%\n  set_colnames(.[1, ]) %>%\n  slice(2:n()) %>%\n  drop_na() %>%\n  gather(key = \"geography\", value = \"population\", -group) %>%\n  mutate(\n    geography = str_to_title(geography),\n    population = as.numeric(population)\n  )\n\n```\n\n\n# Tips for other ONS tables {#tips}\n\nThere is a huge number of ONS tables available, some having different formatting\nissues from those mentioned above. These are some of the issues I've come across\nand potential ways to deal with them.\n\n(The examples below all assume your data is in a data frame/tibble called \n`data`.)\n\n\n## Missing values in the data\n\nMany ONS datasets have missing values, and some even have multiple \nvalues representing different reasons for the values being missing. For example,\ndata for small geographic areas might be missing because the data could not be\ncollected for a particular location or have been redacted to prevent disclosure\nof personal information.\n\nThe `na = ` parameter of `read_excel()` can be used to specify values in the\ndata that should be treated as missing. For example, if an ONS table uses a\nblank cell to represent data that could not be collected and `**` to represent\nredacted data, `read_excel(\"data.xlsx\", sheet = \"Sheet 1\", na = c(\"\", \"**\"))`\nwill ensure both values are represented by `NA` in R.\n\nIt isn't possible to use `drop_na()` to remove empty rows if there are missing \nvalues in the data, because `drop_na()` removes rows that contain *any* missing\nvalues. Instead, you can use `remove_empty()` from the `janitor` package to \nremove rows or columns that are entirely empty. If there are rows that you want\nto remove from the data that contain some missing values and some values that\nare not missing, use `filter()` from `dplyr` based on the value of a specific\ncolumn. For example, to remove rows with the value of `population` missing,\nuse `filter(data, !is.na(population))`. To remove single rows manually by row \nnumber, use `slice()`, also from `dplyr`.\n\n\n## Multiple tables in a single sheet\n\nSometimes multiple related data tables are placed on a single Excel sheet. You\ncan either import them separately and then combine the resulting datasets \nmanually (e.g. with `rbind()`) or just treat the rows or columns between each\ntable as clutter that can be removed using a combination of `drop_na()` and \n`slice()` as above. In the latter case, modify the `range = ` argument of \n`read_excel()` so that the selected cells/rows/columns include all the tables.\n\n\n## Category names or values with footnote markers\n\nIf tables have multiple footnotes, some categories or values may end in a\nfootnote marker (typically a number). To remove these, use `str_remove()` from\n`stringr`. For example, if the column `place` contains values with footnote\nmarkers, you can use `mutate(data, place = str_remove(place, \"\\\\d+$\"))` to \nremove them, where `\\\\d+` is a [regular expression that matches one or more \nnumeric characters](https://stringr.tidyverse.org/articles/regular-expressions.html#matching-multiple-characters)\nand [`$` matches only numeric characters at the end of the\nvalue](https://stringr.tidyverse.org/articles/regular-expressions.html#anchors) \nof `place`. This only works for non-numeric values with numeric footnote \nmarkers, since the regular expression `\\\\d+$` will match any sequence of numbers \nat the end of a cell.\n\n\n## Dates and date ranges stored as text\n\nSince many ONS statistics are published for financial years, time periods are\noften stored as strings showing, for example, `2018-19`. Converting these to\ndates helps with things like plotting values on an axis with date values or\nusing the data in a time-series model.\n\nThe `lubridate` package is very useful for converting dates. You can either\nrepresent each date as a specific moment in time, or as an interval in time.\nFor example, if a financial year is stored as `2018-19` in the `year` column,\nyou can extract the specific moment the year started using\n`mutate(year_beginning = ymd(paste(str_sub(year, 0, 4)), \"04\", \"01\"))`. In this\ncode, `str_sub(year, 0, 4)` extracts the first four characters from the string\n`2018-19`, `paste()` creates a single character value for 1 April in the given\nyear (e.g. `2018 04 01`) and `ymd()` converts that string into a date object.\n\nTo store a date as an interval, we extract both the date on which the year \nstarted and the date it ended. For example,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n  data,\n  year_interval = interval(\n    ymd(paste(str_sub(year, 0, 4), \"04\", \"01\")),\n    ymd(paste(str_sub(year, -2), \"03\", \"31\"))\n  )\n)\n```\n:::\n\n\n\n## R session information\n\nThe code in this tutorial was run in R with the following configuration:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.4.0 (2024-04-24)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sonoma 14.4.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/New_York\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] magrittr_2.0.3  lubridate_1.9.3 forcats_1.0.0   stringr_1.5.1  \n [5] dplyr_1.1.4     purrr_1.0.2     readr_2.1.5     tidyr_1.3.1    \n [9] tibble_3.2.1    ggplot2_3.5.1   tidyverse_2.0.0 readxl_1.4.3   \n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.5      jsonlite_1.8.8    compiler_4.4.0    tidyselect_1.2.1 \n [5] scales_1.3.0      yaml_2.3.8        fastmap_1.1.1     R6_2.5.1         \n [9] generics_0.1.3    knitr_1.46        htmlwidgets_1.6.4 munsell_0.5.1    \n[13] pillar_1.9.0      tzdb_0.4.0        rlang_1.1.3       utf8_1.2.4       \n[17] stringi_1.8.3     xfun_0.43         timechange_0.3.0  cli_3.6.2        \n[21] withr_3.0.0       digest_0.6.35     grid_4.4.0        rstudioapi_0.16.0\n[25] hms_1.1.3         lifecycle_1.0.4   vctrs_0.6.5       evaluate_0.23    \n[29] glue_1.7.0        cellranger_1.1.0  fansi_1.0.6       colorspace_2.1-0 \n[33] rmarkdown_2.26    tools_4.4.0       pkgconfig_2.0.3   htmltools_0.5.8.1\n```\n\n\n:::\n:::\n\n\n[^1]: I have not been able to work out why some ONS files are in `.xls` format\nand some in `.xlsx`.\n\n[^2]: The `readxl` package is [installed as part of the \ntidyverse](https://www.tidyverse.org/packages/) but is not automatically loaded \nby `library(\"tidyverse\")`.\n\n[^3]: ONS refers to this as 'open data', although (almost) all the products it \nproduces are already [open licensed under the Open Government\nLicence](https://www.ons.gov.uk/methodology/geography/licences)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}